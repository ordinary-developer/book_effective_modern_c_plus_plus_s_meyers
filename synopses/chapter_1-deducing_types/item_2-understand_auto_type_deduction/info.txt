 understand auto type deduction
 ##############################

 common
 ======

 --------------------------------------------------------------------
 | template <typename T>                                            |
 | void f(ParamType parameter);                                     |
 |                                                                  | 
 | f(expr);                                                         |
 --------------------------------------------------------------------

 When a variable is declared using "auto", 
 "auto" plays the role of "T" in the template,
 and the type specifier for the variable acts as "ParamType"

 so the next snippets are "equal"
 
 ---------------------------------  ---------------------------------
 | auto x = 27;                  |  | template <typename T>         |
 ---------------------------------  | void f_for_x(T param);        |
                                    |                               |
                                    | f_for_x(27);                  |
                                    ---------------------------------

 --------------------------------   ---------------------------------
 | const auto cx = x;           |   | template <typename T>         |
 --------------------------------   | void f_for_cx(const T param); |
                                    |                               |
                                    | f_for_cx(x);                  |
                                    ---------------------------------

 --------------------------------   ---------------------------------
 | const auto& rx = x;          |   | template <typename T>         |
 --------------------------------   | void f_for_rx(const T& param);|
                                    |                               |
                                    | f_for_rx(x);                  |
                                    ---------------------------------
 
 and rules for template type deducing can be applied


 auxiliary
 =========

 - "auto" type deduction assumes that a braced initializer 
   represents a "std::initializer_list",
   and template type deduction doesn't
 - "auto" in a function return type or a lambda parameter
   implies template type deduction, not "auto" type deduction

