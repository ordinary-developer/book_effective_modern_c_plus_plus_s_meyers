 distinguish between () and {}
 #############################

 pluses
 ======

 braced initialization may be used in the widest variety of contexts

 a novel feature of braced initialization 
 (an initialization with curly braces) is that it prohibits
 implicit "narrowing conversions" amoung built-in types

 braced initialization is immune to C++'s "most vexing parse"
 (when you want do default-construct an object, 
  but inadvertently declare a function instread)


 minuses
 =======

 there is a tangled relashionship among braced initializers,
 std::initializer_lists, and constructor overload resolution

 - when an auto-declared variable has a braced initializer,
   the type deduced is "std::initializer_list"

 - in constructors calls, parentheses and braces 
   have the same meaning as long as "std::initializer_list" parameters
   are not involved

 - if one or more constructors declare a parameter 
   of type"std::initializer_list", calls 
   using the braced initialization syntax 
   STRONGLY prefer the overloads taking "std::initializer_list"s
   (if there any way for compilers to construe a call using
    a braced initializer to be to a constructor taking a
    "std::initializer_list", compilers will employ 
    that interpretation)

 - if there's no way to convert the types of the arguments 
   in a braced initializer to the type in a "std::initializer_list" do
   compilers fall back on normal overload resolution

 - "{}" mean "no arguments", 
       so you get default construction
   "{{}}" or "({})" mean "empty std::initializer_list", 
       so you get the construction from a "std::initializer_list"
       with no elements

